<!doctype html>
<html class="no-js">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" charset="UTF-8">
    <title>Channel</title>
<link href="../../../images/logo-icon.svg" rel="icon" type="image/svg">    <script>var pathToRoot = "../../../";</script>
    <script>document.documentElement.classList.replace("no-js","js");</script>
    <script>const storage = localStorage.getItem("dokka-dark-mode")
    if (storage == null) {
        const osDarkSchemePreferred = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
        if (osDarkSchemePreferred === true) {
            document.getElementsByTagName("html")[0].classList.add("theme-dark")
        }
    } else {
        const savedDarkMode = JSON.parse(storage)
        if(savedDarkMode === true) {
            document.getElementsByTagName("html")[0].classList.add("theme-dark")
        }
    }
    </script>
<script type="text/javascript" src="../../../scripts/sourceset_dependencies.js" async></script>
<link href="../../../styles/style.css" rel="Stylesheet">
<link href="../../../styles/main.css" rel="Stylesheet">
<link href="../../../styles/prism.css" rel="Stylesheet">
<link href="../../../styles/logo-styles.css" rel="Stylesheet">
<link href="../../../styles/font-jb-sans-auto.css" rel="Stylesheet">
<script type="text/javascript" src="../../../scripts/clipboard.js" async></script>
<script type="text/javascript" src="../../../scripts/navigation-loader.js" async></script>
<script type="text/javascript" src="../../../scripts/platform-content-handler.js" async></script>
<script type="text/javascript" src="../../../scripts/main.js" defer></script>
<script type="text/javascript" src="../../../scripts/prism.js" async></script>
<script type="text/javascript" src="../../../scripts/symbol-parameters-wrapper_deferred.js" defer></script></head>
<body>
    <div class="root">
<nav class="navigation" id="navigation-wrapper">
    <div class="navigation--inner">
        <div class="navigation-title">
            <button class="menu-toggle" id="menu-toggle" type="button">toggle menu</button>
            <div class="library-name">
<a class="library-name--link" href="../../../index.html">
                            kotlinx.coroutines
                    </a>            </div>
            <div class="library-version">1.7.1-SNAPSHOT
            </div>
        </div>
        <div class="filter-section" id="filter-section">
                <button class="platform-tag platform-selector common-like" data-active="" data-filter=":kotlinx-coroutines-core:dokkaHtmlPartial/commonMain">common</button>
        </div>
    </div>
    <div class="navigation-controls">
        <button class="navigation-controls--btn navigation-controls--theme" id="theme-toggle-button" type="button">switch theme</button>
        <div class="navigation-controls--btn navigation-controls--search" id="searchBar" role="button">search in API</div>
    </div>
</nav>
        <div id="container">
            <div class="sidebar" id="leftColumn">
                <div class="sidebar--inner" id="sideMenu"></div>
            </div>
            <div id="main">
<div class="main-content" data-page-type="classlike" id="content" pageids="kotlinx-coroutines-core::kotlinx.coroutines.channels/Channel///PointingToDeclaration//1975948010">
  <div class="breadcrumbs"><a href="../../index.html">kotlinx-coroutines-core</a><span class="delimiter">/</span><a href="../index.html">kotlinx.coroutines.channels</a><span class="delimiter">/</span><span class="current">Channel</span></div>
  <div class="cover ">
    <h1 class="cover"><span><span>Channel</span></span></h1>
    <div class="platform-hinted " data-platform-hinted="data-platform-hinted"><div class="content sourceset-dependent-content" data-active="" data-togglable=":kotlinx-coroutines-core:dokkaHtmlPartial/commonMain"><div class="symbol monospace"><span class="token keyword">interface </span><a href="index.html">Channel</a><span class="token operator">&lt;</span><span class="token keyword"></span><a href="index.html">E</a><span class="token operator">&gt;</span> : <a href="../-send-channel/index.html">SendChannel</a><span class="token operator">&lt;</span><span class="token keyword"></span><a href="index.html">E</a><span class="token operator">&gt; </span>, <a href="../-receive-channel/index.html">ReceiveChannel</a><span class="token operator">&lt;</span><span class="token keyword"></span><a href="index.html">E</a><span class="token operator">&gt; </span><span class="clearfix"><span class="floating-right">(<a href="https://github.com/kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-core/common/src/channels/Channel.kt#L716">source</a>)</span></span></div><p class="paragraph">Channel is a non-blocking primitive for communication between a sender (via <a href="../-send-channel/index.html">SendChannel</a>) and a receiver (via <a href="../-receive-channel/index.html">ReceiveChannel</a>). Conceptually, a channel is similar to Java's java.util.concurrent.BlockingQueue, but it has suspending operations instead of blocking ones and can be <a href="../-send-channel/close.html">closed</a>.</p><h3 class=""> Creating channels</h3><p class="paragraph">The <code class="lang-kotlin">Channel(capacity)</code> factory function is used to create channels of different kinds depending on the value of the <code class="lang-kotlin">capacity</code> integer:</p><ul><li><p class="paragraph">When <code class="lang-kotlin">capacity</code> is 0 — it creates a <i>rendezvous</i> channel. This channel does not have any buffer at all. An element is transferred from the sender to the receiver only when <a href="../../../kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/send.html">send</a> and <a href="../../../kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/receive.html">receive</a> invocations meet in time (rendezvous), so <a href="../../../kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/send.html">send</a> suspends until another coroutine invokes <a href="../../../kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/receive.html">receive</a>, and <a href="../../../kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/receive.html">receive</a> suspends until another coroutine invokes <a href="../../../kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/send.html">send</a>.</p></li><li><p class="paragraph">When <code class="lang-kotlin">capacity</code> is <a href="-factory/-u-n-l-i-m-i-t-e-d.html">Channel.UNLIMITED</a> — it creates a channel with effectively unlimited buffer. This channel has a linked-list buffer of unlimited capacity (limited only by available memory). <a href="../../../kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/send.html">Sending</a> to this channel never suspends, and <a href="../../../kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/try-send.html">trySend</a> always succeeds.</p></li><li><p class="paragraph">When <code class="lang-kotlin">capacity</code> is <a href="-factory/-c-o-n-f-l-a-t-e-d.html">Channel.CONFLATED</a> — it creates a <i>conflated</i> channel This channel buffers at most one element and conflates all subsequent <code class="lang-kotlin">send</code> and <code class="lang-kotlin">trySend</code> invocations, so that the receiver always gets the last element sent. Back-to-back sent elements are conflated — only the last sent element is received, while previously sent elements <strong>are lost</strong>. <a href="../../../kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/send.html">Sending</a> to this channel never suspends, and <a href="../../../kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/try-send.html">trySend</a> always succeeds.</p></li><li><p class="paragraph">When <code class="lang-kotlin">capacity</code> is positive but less than <a href="-factory/-u-n-l-i-m-i-t-e-d.html">UNLIMITED</a> — it creates an array-based channel with the specified capacity. This channel has an array buffer of a fixed <code class="lang-kotlin">capacity</code>. <a href="../../../kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/send.html">Sending</a> suspends only when the buffer is full, and <a href="../../../kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/receive.html">receiving</a> suspends only when the buffer is empty.</p></li></ul><p class="paragraph">Buffered channels can be configured with an additional <a href="../-buffer-overflow/index.html"><code class="lang-kotlin">onBufferOverflow</code></a> parameter. It controls the behaviour of the channel's <a href="../../../kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/send.html">send</a> function on buffer overflow:</p><ul><li><p class="paragraph"><a href="../-buffer-overflow/-s-u-s-p-e-n-d/index.html">SUSPEND</a> — the default, suspend <code class="lang-kotlin">send</code> on buffer overflow until there is free space in the buffer.</p></li><li><p class="paragraph"><a href="../-buffer-overflow/-d-r-o-p_-o-l-d-e-s-t/index.html">DROP_OLDEST</a> — do not suspend the <code class="lang-kotlin">send</code>, add the latest value to the buffer, drop the oldest one from the buffer. A channel with <code class="lang-kotlin">capacity = 1</code> and <code class="lang-kotlin">onBufferOverflow = DROP_OLDEST</code> is a <i>conflated</i> channel.</p></li><li><p class="paragraph"><a href="../-buffer-overflow/-d-r-o-p_-l-a-t-e-s-t/index.html">DROP_LATEST</a> — do not suspend the <code class="lang-kotlin">send</code>, drop the value that is being sent, keep the buffer contents intact.</p></li></ul><p class="paragraph">A non-default <code class="lang-kotlin">onBufferOverflow</code> implicitly creates a channel with at least one buffered element and is ignored for a channel with unlimited buffer. It cannot be specified for <code class="lang-kotlin">capacity = CONFLATED</code>, which is a shortcut by itself.</p><h3 class=""> Prompt cancellation guarantee</h3><p class="paragraph">All suspending functions with channels provide <strong>prompt cancellation guarantee</strong>. If the job was cancelled while send or receive function was suspended, it will not resume successfully, but throws a <a href="../../kotlinx.coroutines/-cancellation-exception/index.html">CancellationException</a>. With a single-threaded <a href="../../kotlinx.coroutines/-coroutine-dispatcher/index.html">dispatcher</a> like <a href="../../kotlinx.coroutines/-dispatchers/-main.html">Dispatchers.Main</a> this gives a guarantee that if a piece code running in this thread cancels a <a href="../../kotlinx.coroutines/-job/index.html">Job</a>, then a coroutine running this job cannot resume successfully and continue to run, ensuring a prompt response to its cancellation.</p><blockquote class="quotation"><p class="paragraph"><strong>Prompt cancellation guarantee</strong> for channel operations was added since <code class="lang-kotlin">kotlinx.coroutines</code> version <code class="lang-kotlin">1.4.0</code> and had replaced a channel-specific atomic-cancellation that was not consistent with other suspending functions. The low-level mechanics of prompt cancellation are explained in <a href="../../kotlinx.coroutines/suspend-cancellable-coroutine.html">suspendCancellableCoroutine</a> function.</p></blockquote><h3 class=""> Undelivered elements</h3><p class="paragraph">As a result of a prompt cancellation guarantee, when a closeable resource (like open file or a handle to another native resource) is transferred via channel from one coroutine to another it can fail to be delivered and will be lost if either send or receive operations are cancelled in transit.</p><p class="paragraph">A <code class="lang-kotlin">Channel()</code> constructor function has an <code class="lang-kotlin">onUndeliveredElement</code> optional parameter. When <code class="lang-kotlin">onUndeliveredElement</code> parameter is set, the corresponding function is called once for each element that was sent to the channel with the call to the <a href="../-send-channel/send.html">send</a> function but failed to be delivered, which can happen in the following cases:</p><ul><li><p class="paragraph">When <a href="../-send-channel/send.html">send</a> operation throws an exception because it was cancelled before it had a chance to actually send the element or because the channel was <a href="../-send-channel/close.html">closed</a> or <a href="../-receive-channel/cancel.html">cancelled</a>.</p></li><li><p class="paragraph">When <a href="../-receive-channel/receive.html">receive</a>, <a href="../../../kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive-or-null.html">receiveOrNull</a>, or <a href="../-channel-iterator/has-next.html">hasNext</a> operation throws an exception when it had retrieved the element from the channel but was cancelled before the code following the receive call resumed.</p></li><li><p class="paragraph">The channel was <a href="../-receive-channel/cancel.html">cancelled</a>, in which case <code class="lang-kotlin">onUndeliveredElement</code> is called on every remaining element in the channel's buffer.</p></li></ul><p class="paragraph">Note, that <code class="lang-kotlin">onUndeliveredElement</code> function is called synchronously in an arbitrary context. It should be fast, non-blocking, and should not throw exceptions. Any exception thrown by <code class="lang-kotlin">onUndeliveredElement</code> is wrapped into an internal runtime exception which is either rethrown from the caller method or handed off to the exception handler in the current context (see <a href="../../kotlinx.coroutines/-coroutine-exception-handler/index.html">CoroutineExceptionHandler</a>) when one is available.</p><p class="paragraph">A typical usage for <code class="lang-kotlin">onUndeliveredElement</code> is to close a resource that is being transferred via the channel. The following code pattern guarantees that opened resources are closed even if producer, consumer, and/or channel are cancelled. Resources are never lost.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">// Create the channel with onUndeliveredElement block that closes a resource<br>val channel = Channel&lt;Resource&gt;(capacity) { resource -&gt; resource.close() }<br><br>// Producer code<br>val resourceToSend = openResource()<br>channel.send(resourceToSend)<br><br>// Consumer code<br>val resourceReceived = channel.receive()<br>try {<br>    // work with received resource<br>} finally {<br>    resourceReceived.close()<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><blockquote class="quotation"><p class="paragraph">Note, that if you do any kind of work in between <code class="lang-kotlin">openResource()</code> and <code class="lang-kotlin">channel.send(...)</code>, then you should ensure that resource gets closed in case this additional code fails.</p></blockquote></div></div>
  </div>
  <div class="tabbedcontent">
    <div class="tabs-section" tabs-section="tabs-section"><button class="section-tab" data-active="" data-togglable="CONSTRUCTOR,TYPE,PROPERTY,FUNCTION">Members</button></div>
    <div class="tabs-section-body">
      <div data-togglable="TYPE">
        <h2 class="">Types</h2>
        <div class="table"><a data-name="-951096331%2FClasslikes%2F1975948010" anchor-label="Factory" id="-951096331%2FClasslikes%2F1975948010" data-filterable-set=":kotlinx-coroutines-core:dokkaHtmlPartial/commonMain"></a>
          <div class="table-row" data-filterable-current=":kotlinx-coroutines-core:dokkaHtmlPartial/commonMain" data-filterable-set=":kotlinx-coroutines-core:dokkaHtmlPartial/commonMain">
            <div class="main-subrow keyValue ">
              <div class=""><span class="inline-flex">
                  <div><a href="-factory/index.html"><span><span>Factory</span></span></a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="-951096331%2FClasslikes%2F1975948010"></span>
                    <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
                  </span></span></div>
              <div>
                <div class="title">
                  <div class="platform-hinted " data-platform-hinted="data-platform-hinted"><div class="content sourceset-dependent-content" data-active="" data-togglable=":kotlinx-coroutines-core:dokkaHtmlPartial/commonMain"><div class="symbol monospace"><span class="token keyword">object </span><a href="-factory/index.html">Factory</a></div><div class="brief "><p class="paragraph">Constants for the channel factory function <code class="lang-kotlin">Channel()</code>.</p></div></div></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
      <div class="footer">
        <span class="go-to-top-icon"><a href="#content" id="go-to-top-link"></a></span><span>© 2023 Copyright</span><span class="pull-right"><span>Generated by </span><a href="https://github.com/Kotlin/dokka"><span>dokka</span><span class="padded-icon"></span></a></span>
      </div>
            </div>
        </div>
    </div>
</body>
</html>

