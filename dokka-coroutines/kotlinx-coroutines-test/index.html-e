<!doctype html>
<html class="no-js">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" charset="UTF-8">
    <title>kotlinx-coroutines-test</title><meta name="robots" content="noindex, nofollow">
<link href="../images/logo-icon.svg" rel="icon" type="image/svg"><script>var pathToRoot = "../";</script>
    <script>document.documentElement.classList.replace("no-js","js");</script>    <script>const storage = localStorage.getItem("dokka-dark-mode")
    if (storage == null) {
        const osDarkSchemePreferred = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
        if (osDarkSchemePreferred === true) {
            document.getElementsByTagName("html")[0].classList.add("theme-dark")
        }
    } else {
        const savedDarkMode = JSON.parse(storage)
        if(savedDarkMode === true) {
            document.getElementsByTagName("html")[0].classList.add("theme-dark")
        }
    }
    </script>
<script type="text/javascript" src="../scripts/sourceset_dependencies.js" async></script>
<link href="../styles/style.css" rel="Stylesheet">
<link href="../styles/main.css" rel="Stylesheet">
<link href="../styles/prism.css" rel="Stylesheet">
<link href="../styles/logo-styles.css" rel="Stylesheet">
<script type="text/javascript" src="../scripts/clipboard.js" async></script>
<script type="text/javascript" src="../scripts/navigation-loader.js" async></script>
<script type="text/javascript" src="../scripts/platform-content-handler.js" async></script>
<script type="text/javascript" src="../scripts/main.js" defer></script>
<script type="text/javascript" src="../scripts/prism.js" async></script>
<script type="text/javascript" src="../scripts/symbol-parameters-wrapper_deferred.js" defer></script></head>
<body>
    <div class="root">
<nav class="navigation" id="navigation-wrapper">
    <div class="navigation--inner">
        <div class="navigation-title">
            <button class="menu-toggle" id="menu-toggle" type="button">toggle menu</button>
            <div class="library-name">
<a class="library-name--link" href="../index.html">
                            kotlinx.coroutines
                    </a>            </div>
            <div class="library-version">1.7.1-SNAPSHOT
            </div>
        </div>
        <div class="filter-section" id="filter-section">
                <button class="platform-tag platform-selector common-like" data-active="" data-filter=":kotlinx-coroutines-test:dokkaHtmlPartial/commonMain">common</button>
                <button class="platform-tag platform-selector js-like" data-active="" data-filter=":kotlinx-coroutines-test:dokkaHtmlPartial/jsMain">js</button>
                <button class="platform-tag platform-selector jvm-like" data-active="" data-filter=":kotlinx-coroutines-test:dokkaHtmlPartial/jvmMain">jvm</button>
                <button class="platform-tag platform-selector common-like" data-active="" data-filter=":kotlinx-coroutines-test:dokkaHtmlPartial/nativeMain">native</button>
        </div>
    </div>
    <div class="navigation-controls">
        <button class="navigation-controls--btn navigation-controls--theme" id="theme-toggle-button" type="button">switch theme</button>
        <div class="navigation-controls--btn navigation-controls--search" id="searchBar" role="button">search in API</div>
    </div>
</nav>
        <div id="container">
            <div class="sidebar" id="leftColumn">
                <div class="sidebar--inner" id="sideMenu"></div>
            </div>
            <div id="main">
<div class="main-content" id="content" pageids="kotlinx-coroutines-test::////PointingToDeclaration//2093488082">
  <div class="breadcrumbs"></div>
  <div class="cover ">
    <h1 class="cover"><span><span>kotlinx-coroutines-test</span></span></h1>
    <div class="platform-hinted UnderCoverText with-platform-tabs" data-platform-hinted="data-platform-hinted">
      <div class="platform-bookmarks-row" data-toggle-list="data-toggle-list"><button class="platform-bookmark" data-filterable-current=":kotlinx-coroutines-test:dokkaHtmlPartial/commonMain" data-filterable-set=":kotlinx-coroutines-test:dokkaHtmlPartial/commonMain" data-active="" data-toggle=":kotlinx-coroutines-test:dokkaHtmlPartial/commonMain">common</button><button class="platform-bookmark" data-filterable-current=":kotlinx-coroutines-test:dokkaHtmlPartial/jsMain" data-filterable-set=":kotlinx-coroutines-test:dokkaHtmlPartial/jsMain" data-toggle=":kotlinx-coroutines-test:dokkaHtmlPartial/jsMain">js</button><button class="platform-bookmark" data-filterable-current=":kotlinx-coroutines-test:dokkaHtmlPartial/jvmMain" data-filterable-set=":kotlinx-coroutines-test:dokkaHtmlPartial/jvmMain" data-toggle=":kotlinx-coroutines-test:dokkaHtmlPartial/jvmMain">jvm</button><button class="platform-bookmark" data-filterable-current=":kotlinx-coroutines-test:dokkaHtmlPartial/nativeMain" data-filterable-set=":kotlinx-coroutines-test:dokkaHtmlPartial/nativeMain" data-toggle=":kotlinx-coroutines-test:dokkaHtmlPartial/nativeMain">native</button></div>
<div class="content sourceset-dependent-content" data-active="" data-togglable=":kotlinx-coroutines-test:dokkaHtmlPartial/commonMain"><p class="paragraph">Test utilities for <code class="lang-kotlin">kotlinx.coroutines</code>.</p><h2 class=""> Overview</h2><p class="paragraph">This package provides utilities for efficiently testing coroutines.</p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a></td><td>Runs the test code, automatically skipping delays and handling uncaught exceptions.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a></td><td>The shared source of virtual time, used for controlling execution order and skipping delays.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a></td><td>A <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> that integrates with <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a>, providing access to <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a></td><td>A <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">CoroutineDispatcher</a> whose delays are controlled by a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/set-main.html">Dispatchers.setMain</a></td><td>Mocks the main dispatcher using the provided one. If mocked with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a>, its <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a> is used everywhere by default.</td></tr></tbody></table><p class="paragraph">Provided <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a> implementations:</p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-standard-test-dispatcher.html">StandardTestDispatcher</a></td><td>A simple dispatcher with no special behavior other than being linked to a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-unconfined-test-dispatcher.html">UnconfinedTestDispatcher</a></td><td>A dispatcher that behaves like <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html">Dispatchers.Unconfined</a>.</td></tr></tbody></table><h2 class=""> Using in your project</h2><p class="paragraph">Add <code class="lang-kotlin">kotlinx-coroutines-test</code> to your project test dependencies:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">dependencies {<br>    testImplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.1'<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph"><strong>Do not</strong> depend on this project in your main sources, all utilities here are intended and designed to be used only from tests.</p><h2 class=""> Dispatchers.Main Delegation</h2><p class="paragraph"><code class="lang-kotlin">Dispatchers.setMain</code> will override the <code class="lang-kotlin">Main</code> dispatcher in test scenarios. This is helpful when one wants to execute a test in situations where the platform <code class="lang-kotlin">Main</code> dispatcher is not available, or to replace <code class="lang-kotlin">Dispatchers.Main</code> with a testing dispatcher.</p><p class="paragraph">On the JVM, the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html"><code class="lang-kotlin">ServiceLoader</code></a> mechanism is responsible for overwriting <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html">Dispatchers.Main</a> with a testable implementation, which by default will delegate its calls to the real <code class="lang-kotlin">Main</code> dispatcher, if any.</p><p class="paragraph">The <code class="lang-kotlin">Main</code> implementation can be overridden using <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/set-main.html">Dispatchers.setMain</a> method with any <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">CoroutineDispatcher</a> implementation, e.g.:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">class SomeTest {<br><br>    private val mainThreadSurrogate = newSingleThreadContext("UI thread")<br><br>    @Before<br>    fun setUp() {<br>        Dispatchers.setMain(mainThreadSurrogate)<br>    }<br><br>    @After<br>    fun tearDown() {<br>        Dispatchers.resetMain() // reset the main dispatcher to the original Main dispatcher<br>        mainThreadSurrogate.close()<br>    }<br><br>    @Test<br>    fun testSomeUI() = runBlocking {<br>        launch(Dispatchers.Main) {  // Will be launched in the mainThreadSurrogate dispatcher<br>            // ...<br>        }<br>    }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Calling <code class="lang-kotlin">setMain</code> or <code class="lang-kotlin">resetMain</code> immediately changes the <code class="lang-kotlin">Main</code> dispatcher globally.</p><p class="paragraph">If <code class="lang-kotlin">Main</code> is overridden with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a>, then its <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a> is used when new <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a> or <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a> instances are created without <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a> being passed as an argument.</p><h2 class=""> runTest</h2><p class="paragraph"><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> is the way to test code that involves coroutines. <code class="lang-kotlin">suspend</code> functions can be called inside it.</p><p class="paragraph"><strong>IMPORTANT: in order to work with on Kotlin/JS, the result of </strong><code class="strong lang-kotlin"><strong>runTest</strong></code><strong> must be immediately </strong><code class="strong lang-kotlin"><strong>return</strong></code><strong>-ed from each test.</strong> The typical invocation of <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> thus looks like this:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFoo() = runTest {<br>    // code under test<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">In more advanced scenarios, it's possible instead to use the following form:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFoo(): TestResult {<br>    // initialize some test state<br>    return runTest {<br>        // code under test<br>    }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph"><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> is similar to running the code with <code class="lang-kotlin">runBlocking</code> on Kotlin/JVM and Kotlin/Native, or launching a new promise on Kotlin/JS. The main differences are the following:</p><ul><li><p class="paragraph"><strong>The calls to </strong><code class="strong lang-kotlin"><strong>delay</strong></code><strong> are automatically skipped</strong>, preserving the relative execution order of the tasks. This way,   it's possible to make tests finish more-or-less immediately.</p></li><li><p class="paragraph"><strong>The execution times out after 10 seconds</strong>, cancelling the test coroutine to prevent tests from hanging forever    and eating up the CI resources.</p></li><li><p class="paragraph"><strong>Controlling the virtual time</strong>: in case just skipping delays is not sufficient, it's possible to more carefully   guide the execution, advancing the virtual time by a duration, draining the queue of the awaiting tasks, or running   the tasks scheduled at the present moment.</p></li><li><p class="paragraph"><strong>Handling uncaught exceptions</strong> spawned in the child coroutines by throwing them at the end of the test.</p></li><li><p class="paragraph"><strong>Waiting for asynchronous callbacks</strong>.   Sometimes, especially when working with third-party code, it's impossible to mock all the dispatchers in use.   <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> will handle the situations where some code runs in dispatchers not integrated with the test module.</p></li></ul><h2 class=""> Timeout</h2><p class="paragraph">Test automatically time out after 10 seconds. For example, this test will fail with a timeout exception:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testHanging() = runTest {<br>    CompletableDeferred&lt;Unit&gt;().await() // will hang forever<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">In case the test is expected to take longer than 10 seconds, the timeout can be increased by passing the <code class="lang-kotlin">timeout</code> parameter:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testTakingALongTime() = runTest(timeout = 30.seconds) {<br>    val result = withContext(Dispatchers.Default) {<br>        delay(20.seconds) // this delay is not in the test dispatcher and will not be skipped<br>        3<br>    }<br>    assertEquals(3, result)<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Delay-skipping</h2><p class="paragraph">To test regular suspend functions, which may have a delay, just run them inside the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> block.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFoo() = runTest { // a coroutine with an extra test control<br>    val actual = foo()<br>    // ...<br>}<br><br>suspend fun foo() {<br>    delay(1_000) // when run in `runTest`, will finish immediately instead of delaying<br>    // ...<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> <code class="lang-kotlin">launch</code> and <code class="lang-kotlin">async</code></h2><p class="paragraph">The coroutine dispatcher used for tests is single-threaded, meaning that the child coroutines of the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> block will run on the thread that started the test, and will never run in parallel.</p><p class="paragraph">If several coroutines are waiting to be executed next, the one scheduled after the smallest delay will be chosen. The virtual time will automatically advance to the point of its resumption.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testWithMultipleDelays() = runTest {<br>    launch {<br>        delay(1_000)<br>        println("1. $currentTime") // 1000<br>        delay(200)<br>        println("2. $currentTime") // 1200<br>        delay(2_000)<br>        println("4. $currentTime") // 3200<br>    }<br>    val deferred = async {<br>        delay(3_000)<br>        println("3. $currentTime") // 3000<br>        delay(500)<br>        println("5. $currentTime") // 3500<br>    }<br>    deferred.await()<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Controlling the virtual time</h2><p class="paragraph">Inside <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a>, the execution is scheduled by <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>, which is a virtual time scheduler. The scheduler has several special methods that allow controlling the virtual time:</p><ul><li><p class="paragraph"><code class="lang-kotlin">currentTime</code> gets the current virtual time.</p></li><li><p class="paragraph"><code class="lang-kotlin">runCurrent()</code> runs the tasks that are scheduled at this point of virtual time.</p></li><li><p class="paragraph"><code class="lang-kotlin">advanceUntilIdle()</code> runs all enqueued tasks until there are no more.</p></li><li><p class="paragraph"><code class="lang-kotlin">advanceTimeBy(timeDelta)</code> runs the enqueued tasks until the current virtual time advances by <code class="lang-kotlin">timeDelta</code>.</p></li><li><p class="paragraph"><code class="lang-kotlin">timeSource</code> returns a <code class="lang-kotlin">TimeSource</code> that uses the virtual time.</p></li></ul><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFoo() = runTest {<br>    launch {<br>        val workDuration = testScheduler.timeSource.measureTime {<br>            println(1)   // executes during runCurrent()<br>            delay(1_000) // suspends until time is advanced by at least 1_000<br>            println(2)   // executes during advanceTimeBy(2_000)<br>            delay(500)   // suspends until the time is advanced by another 500 ms<br>            println(3)   // also executes during advanceTimeBy(2_000)<br>            delay(5_000) // will suspend by another 4_500 ms<br>            println(4)   // executes during advanceUntilIdle()<br>        }<br>        assertEquals(6500.milliseconds, workDuration) // the work took 6_500 ms of virtual time<br>    }<br>    // the child coroutine has not run yet<br>    testScheduler.runCurrent()<br>    // the child coroutine has called println(1), and is suspended on delay(1_000)<br>    testScheduler.advanceTimeBy(2.seconds) // progress time, this will cause two calls to `delay` to resume<br>    // the child coroutine has called println(2) and println(3) and suspends for another 4_500 virtual milliseconds<br>    testScheduler.advanceUntilIdle() // will run the child coroutine to completion<br>    assertEquals(6500, currentTime) // the child coroutine finished at virtual time of 6_500 milliseconds<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Using multiple test dispatchers</h2><p class="paragraph">The virtual time is controlled by an entity called the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>, which behaves as the shared source of virtual time.</p><p class="paragraph">Several dispatchers can be created that use the same <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>, in which case they will share their knowledge of the virtual time.</p><p class="paragraph">To access the scheduler used for this test, use the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/test-scheduler.html">TestScope.testScheduler</a> property.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testWithMultipleDispatchers() = runTest {<br>        val scheduler = testScheduler // the scheduler used for this test<br>        val dispatcher1 = StandardTestDispatcher(scheduler, name = "IO dispatcher")<br>        val dispatcher2 = StandardTestDispatcher(scheduler, name = "Background dispatcher")<br>        launch(dispatcher1) {<br>            delay(1_000)<br>            println("1. $currentTime") // 1000<br>            delay(200)<br>            println("2. $currentTime") // 1200<br>            delay(2_000)<br>            println("4. $currentTime") // 3200<br>        }<br>        val deferred = async(dispatcher2) {<br>            delay(3_000)<br>            println("3. $currentTime") // 3000<br>            delay(500)<br>            println("5. $currentTime") // 3500<br>        }<br>        deferred.await()<br>    }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph"><strong>Note: if </strong><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html"><strong>Dispatchers.Main</strong></a><strong> is replaced by a </strong><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html"><strong>TestDispatcher</strong></a><strong>, </strong><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html"><strong>runTest</strong></a><strong> will automatically use its scheduler. This is done so that there is no need to go through the ceremony of passing the correct scheduler to </strong><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html"><strong>runTest</strong></a><strong>.</strong></p><h2 class=""> Accessing the test coroutine scope</h2><p class="paragraph">Structured concurrency ties coroutines to scopes in which they are launched. <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a> is a special coroutine scope designed for testing coroutines, and a new one is automatically created for <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> and used as the receiver for the test body.</p><p class="paragraph">However, it can be convenient to access a <code class="lang-kotlin">CoroutineScope</code> before the test has started, for example, to perform mocking of some parts of the system in <code class="lang-kotlin">@BeforeTest</code> via dependency injection. In these cases, it is possible to manually create <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a>, the scope for the test coroutines, in advance, before the test begins.</p><p class="paragraph"><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a> on its own does not automatically run the code launched in it. In addition, it is stateful in order to keep track of executing coroutines and uncaught exceptions. Therefore, it is important to ensure that <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">TestScope.runTest</a> is called eventually.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">val scope = TestScope()<br><br>@BeforeTest<br>fun setUp() {<br>    Dispatchers.setMain(StandardTestDispatcher(scope.testScheduler))<br>    TestSubject.setScope(scope)<br>}<br><br>@AfterTest<br>fun tearDown() {<br>    Dispatchers.resetMain()<br>    TestSubject.resetScope()<br>}<br><br>@Test<br>fun testSubject() = scope.runTest {<br>    // the receiver here is `testScope`<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Running background work</h2><p class="paragraph">Sometimes, the fact that <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> waits for all the coroutines to finish is undesired. For example, the system under test may need to receive data from coroutines that always run in the background. Emulating such coroutines by launching them from the test body is not sufficient, because <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> will wait for them to finish, which they never typically do.</p><p class="paragraph">For these cases, there is a special coroutine scope: <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/background-scope.html">TestScope.backgroundScope</a>. Coroutines launched in it will be cancelled at the end of the test.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testExampleBackgroundJob() = runTest {<br>  val channel = Channel&lt;Int&gt;()<br>  backgroundScope.launch {<br>    var i = 0<br>    while (true) {<br>      channel.send(i++)<br>    }<br>  }<br>  repeat(100) {<br>    assertEquals(it, channel.receive())<br>  }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Eagerly entering <code class="lang-kotlin">launch</code> and <code class="lang-kotlin">async</code> blocks</h2><p class="paragraph">Some tests only test functionality and don't particularly care about the precise order in which coroutines are dispatched. In these cases, it can be cumbersome to always call <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-current.html">runCurrent</a> or <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html">yield</a> to observe the effects of the coroutines after they are launched.</p><p class="paragraph">If <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> executes with an <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-unconfined-test-dispatcher.html">UnconfinedTestDispatcher</a>, the child coroutines launched at the top level are entered <i>eagerly</i>, that is, they don't go through a dispatch until the first suspension.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testEagerlyEnteringChildCoroutines() = runTest(UnconfinedTestDispatcher()) {<br>    var entered = false<br>    val deferred = CompletableDeferred&lt;Unit&gt;()<br>    var completed = false<br>    launch {<br>        entered = true<br>        deferred.await()<br>        completed = true<br>    }<br>    assertTrue(entered) // `entered = true` already executed.<br>    assertFalse(completed) // however, the child coroutine then suspended, so it is enqueued.<br>    deferred.complete(Unit) // resume the coroutine.<br>    assertTrue(completed) // now the child coroutine is immediately completed.<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">If this behavior is desirable, but some parts of the test still require accurate dispatching, for example, to ensure that the code executes on the correct thread, then simply <code class="lang-kotlin">launch</code> a new coroutine with the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-standard-test-dispatcher.html">StandardTestDispatcher</a>.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testEagerlyEnteringSomeChildCoroutines() = runTest(UnconfinedTestDispatcher()) {<br>    var entered1 = false<br>    launch {<br>        entered1 = true<br>    }<br>    assertTrue(entered1) // `entered1 = true` already executed<br><br>    var entered2 = false<br>    launch(StandardTestDispatcher(testScheduler)) {<br>        // this block and every coroutine launched inside it will explicitly go through the needed dispatches<br>        entered2 = true<br>    }<br>    assertFalse(entered2)<br>    runCurrent() // need to explicitly run the dispatched continuation<br>    assertTrue(entered2)<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class=""> Using <code class="lang-kotlin">withTimeout</code> inside <code class="lang-kotlin">runTest</code></h3><p class="paragraph">Timeouts are also susceptible to time control, so the code below will immediately finish.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFooWithTimeout() = runTest {<br>    assertFailsWith&lt;TimeoutCancellationException&gt; {<br>        withTimeout(1_000) {<br>            delay(999)<br>            delay(2)<br>            println("this won't be reached")<br>        }<br>    }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Virtual time support with other dispatchers</h2><p class="paragraph">Calls to <code class="lang-kotlin">withContext(Dispatchers.IO)</code>, <code class="lang-kotlin">withContext(Dispatchers.Default)</code> ,and <code class="lang-kotlin">withContext(Dispatchers.Main)</code> are common in coroutines-based code bases. Unfortunately, just executing code in a test will not lead to these dispatchers using the virtual time source, so delays will not be skipped in them.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">suspend fun veryExpensiveFunction() = withContext(Dispatchers.Default) {<br>    delay(1_000)<br>    1<br>}<br><br>fun testExpensiveFunction() = runTest {<br>    val result = veryExpensiveFunction() // will take a whole real-time second to execute<br>    // the virtual time at this point is still 0<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Tests should, when possible, replace these dispatchers with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a> if the <code class="lang-kotlin">withContext</code> calls <code class="lang-kotlin">delay</code> in the function under test. For example, <code class="lang-kotlin">veryExpensiveFunction</code> above should allow mocking with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a> using either dependency injection, a service locator, or a default parameter, if it is to be used with virtual time.</p><h3 class=""> Status of the API</h3><p class="paragraph">Many parts of the API is experimental, and it is may change before migrating out of experimental (while it is marked as <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-experimental-coroutines-api/index.html"><code class="lang-kotlin">@ExperimentalCoroutinesApi</code></a>). Changes during experimental may have deprecation applied when possible, but it is not advised to use the API in stable code before it leaves experimental due to possible breaking changes.</p><p class="paragraph">If you have any suggestions for improvements to this experimental API please share them on the <a href="https://github.com/Kotlin/kotlinx.coroutines/issues">issue tracker</a>.</p><!-- MODULE kotlinx-coroutines-core --><!-- INDEX kotlinx.coroutines --><!-- MODULE kotlinx-coroutines-test --><!-- INDEX kotlinx.coroutines.test --><!-- END --></div><div class="content sourceset-dependent-content" data-togglable=":kotlinx-coroutines-test:dokkaHtmlPartial/jsMain"><p class="paragraph">Test utilities for <code class="lang-kotlin">kotlinx.coroutines</code>.</p><h2 class=""> Overview</h2><p class="paragraph">This package provides utilities for efficiently testing coroutines.</p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a></td><td>Runs the test code, automatically skipping delays and handling uncaught exceptions.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a></td><td>The shared source of virtual time, used for controlling execution order and skipping delays.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a></td><td>A <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> that integrates with <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a>, providing access to <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a></td><td>A <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">CoroutineDispatcher</a> whose delays are controlled by a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/set-main.html">Dispatchers.setMain</a></td><td>Mocks the main dispatcher using the provided one. If mocked with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a>, its <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a> is used everywhere by default.</td></tr></tbody></table><p class="paragraph">Provided <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a> implementations:</p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-standard-test-dispatcher.html">StandardTestDispatcher</a></td><td>A simple dispatcher with no special behavior other than being linked to a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-unconfined-test-dispatcher.html">UnconfinedTestDispatcher</a></td><td>A dispatcher that behaves like <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html">Dispatchers.Unconfined</a>.</td></tr></tbody></table><h2 class=""> Using in your project</h2><p class="paragraph">Add <code class="lang-kotlin">kotlinx-coroutines-test</code> to your project test dependencies:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">dependencies {<br>    testImplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.1'<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph"><strong>Do not</strong> depend on this project in your main sources, all utilities here are intended and designed to be used only from tests.</p><h2 class=""> Dispatchers.Main Delegation</h2><p class="paragraph"><code class="lang-kotlin">Dispatchers.setMain</code> will override the <code class="lang-kotlin">Main</code> dispatcher in test scenarios. This is helpful when one wants to execute a test in situations where the platform <code class="lang-kotlin">Main</code> dispatcher is not available, or to replace <code class="lang-kotlin">Dispatchers.Main</code> with a testing dispatcher.</p><p class="paragraph">On the JVM, the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html"><code class="lang-kotlin">ServiceLoader</code></a> mechanism is responsible for overwriting <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html">Dispatchers.Main</a> with a testable implementation, which by default will delegate its calls to the real <code class="lang-kotlin">Main</code> dispatcher, if any.</p><p class="paragraph">The <code class="lang-kotlin">Main</code> implementation can be overridden using <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/set-main.html">Dispatchers.setMain</a> method with any <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">CoroutineDispatcher</a> implementation, e.g.:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">class SomeTest {<br><br>    private val mainThreadSurrogate = newSingleThreadContext("UI thread")<br><br>    @Before<br>    fun setUp() {<br>        Dispatchers.setMain(mainThreadSurrogate)<br>    }<br><br>    @After<br>    fun tearDown() {<br>        Dispatchers.resetMain() // reset the main dispatcher to the original Main dispatcher<br>        mainThreadSurrogate.close()<br>    }<br><br>    @Test<br>    fun testSomeUI() = runBlocking {<br>        launch(Dispatchers.Main) {  // Will be launched in the mainThreadSurrogate dispatcher<br>            // ...<br>        }<br>    }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Calling <code class="lang-kotlin">setMain</code> or <code class="lang-kotlin">resetMain</code> immediately changes the <code class="lang-kotlin">Main</code> dispatcher globally.</p><p class="paragraph">If <code class="lang-kotlin">Main</code> is overridden with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a>, then its <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a> is used when new <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a> or <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a> instances are created without <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a> being passed as an argument.</p><h2 class=""> runTest</h2><p class="paragraph"><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> is the way to test code that involves coroutines. <code class="lang-kotlin">suspend</code> functions can be called inside it.</p><p class="paragraph"><strong>IMPORTANT: in order to work with on Kotlin/JS, the result of </strong><code class="strong lang-kotlin"><strong>runTest</strong></code><strong> must be immediately </strong><code class="strong lang-kotlin"><strong>return</strong></code><strong>-ed from each test.</strong> The typical invocation of <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> thus looks like this:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFoo() = runTest {<br>    // code under test<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">In more advanced scenarios, it's possible instead to use the following form:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFoo(): TestResult {<br>    // initialize some test state<br>    return runTest {<br>        // code under test<br>    }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph"><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> is similar to running the code with <code class="lang-kotlin">runBlocking</code> on Kotlin/JVM and Kotlin/Native, or launching a new promise on Kotlin/JS. The main differences are the following:</p><ul><li><p class="paragraph"><strong>The calls to </strong><code class="strong lang-kotlin"><strong>delay</strong></code><strong> are automatically skipped</strong>, preserving the relative execution order of the tasks. This way,   it's possible to make tests finish more-or-less immediately.</p></li><li><p class="paragraph"><strong>The execution times out after 10 seconds</strong>, cancelling the test coroutine to prevent tests from hanging forever    and eating up the CI resources.</p></li><li><p class="paragraph"><strong>Controlling the virtual time</strong>: in case just skipping delays is not sufficient, it's possible to more carefully   guide the execution, advancing the virtual time by a duration, draining the queue of the awaiting tasks, or running   the tasks scheduled at the present moment.</p></li><li><p class="paragraph"><strong>Handling uncaught exceptions</strong> spawned in the child coroutines by throwing them at the end of the test.</p></li><li><p class="paragraph"><strong>Waiting for asynchronous callbacks</strong>.   Sometimes, especially when working with third-party code, it's impossible to mock all the dispatchers in use.   <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> will handle the situations where some code runs in dispatchers not integrated with the test module.</p></li></ul><h2 class=""> Timeout</h2><p class="paragraph">Test automatically time out after 10 seconds. For example, this test will fail with a timeout exception:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testHanging() = runTest {<br>    CompletableDeferred&lt;Unit&gt;().await() // will hang forever<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">In case the test is expected to take longer than 10 seconds, the timeout can be increased by passing the <code class="lang-kotlin">timeout</code> parameter:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testTakingALongTime() = runTest(timeout = 30.seconds) {<br>    val result = withContext(Dispatchers.Default) {<br>        delay(20.seconds) // this delay is not in the test dispatcher and will not be skipped<br>        3<br>    }<br>    assertEquals(3, result)<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Delay-skipping</h2><p class="paragraph">To test regular suspend functions, which may have a delay, just run them inside the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> block.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFoo() = runTest { // a coroutine with an extra test control<br>    val actual = foo()<br>    // ...<br>}<br><br>suspend fun foo() {<br>    delay(1_000) // when run in `runTest`, will finish immediately instead of delaying<br>    // ...<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> <code class="lang-kotlin">launch</code> and <code class="lang-kotlin">async</code></h2><p class="paragraph">The coroutine dispatcher used for tests is single-threaded, meaning that the child coroutines of the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> block will run on the thread that started the test, and will never run in parallel.</p><p class="paragraph">If several coroutines are waiting to be executed next, the one scheduled after the smallest delay will be chosen. The virtual time will automatically advance to the point of its resumption.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testWithMultipleDelays() = runTest {<br>    launch {<br>        delay(1_000)<br>        println("1. $currentTime") // 1000<br>        delay(200)<br>        println("2. $currentTime") // 1200<br>        delay(2_000)<br>        println("4. $currentTime") // 3200<br>    }<br>    val deferred = async {<br>        delay(3_000)<br>        println("3. $currentTime") // 3000<br>        delay(500)<br>        println("5. $currentTime") // 3500<br>    }<br>    deferred.await()<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Controlling the virtual time</h2><p class="paragraph">Inside <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a>, the execution is scheduled by <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>, which is a virtual time scheduler. The scheduler has several special methods that allow controlling the virtual time:</p><ul><li><p class="paragraph"><code class="lang-kotlin">currentTime</code> gets the current virtual time.</p></li><li><p class="paragraph"><code class="lang-kotlin">runCurrent()</code> runs the tasks that are scheduled at this point of virtual time.</p></li><li><p class="paragraph"><code class="lang-kotlin">advanceUntilIdle()</code> runs all enqueued tasks until there are no more.</p></li><li><p class="paragraph"><code class="lang-kotlin">advanceTimeBy(timeDelta)</code> runs the enqueued tasks until the current virtual time advances by <code class="lang-kotlin">timeDelta</code>.</p></li><li><p class="paragraph"><code class="lang-kotlin">timeSource</code> returns a <code class="lang-kotlin">TimeSource</code> that uses the virtual time.</p></li></ul><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFoo() = runTest {<br>    launch {<br>        val workDuration = testScheduler.timeSource.measureTime {<br>            println(1)   // executes during runCurrent()<br>            delay(1_000) // suspends until time is advanced by at least 1_000<br>            println(2)   // executes during advanceTimeBy(2_000)<br>            delay(500)   // suspends until the time is advanced by another 500 ms<br>            println(3)   // also executes during advanceTimeBy(2_000)<br>            delay(5_000) // will suspend by another 4_500 ms<br>            println(4)   // executes during advanceUntilIdle()<br>        }<br>        assertEquals(6500.milliseconds, workDuration) // the work took 6_500 ms of virtual time<br>    }<br>    // the child coroutine has not run yet<br>    testScheduler.runCurrent()<br>    // the child coroutine has called println(1), and is suspended on delay(1_000)<br>    testScheduler.advanceTimeBy(2.seconds) // progress time, this will cause two calls to `delay` to resume<br>    // the child coroutine has called println(2) and println(3) and suspends for another 4_500 virtual milliseconds<br>    testScheduler.advanceUntilIdle() // will run the child coroutine to completion<br>    assertEquals(6500, currentTime) // the child coroutine finished at virtual time of 6_500 milliseconds<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Using multiple test dispatchers</h2><p class="paragraph">The virtual time is controlled by an entity called the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>, which behaves as the shared source of virtual time.</p><p class="paragraph">Several dispatchers can be created that use the same <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>, in which case they will share their knowledge of the virtual time.</p><p class="paragraph">To access the scheduler used for this test, use the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/test-scheduler.html">TestScope.testScheduler</a> property.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testWithMultipleDispatchers() = runTest {<br>        val scheduler = testScheduler // the scheduler used for this test<br>        val dispatcher1 = StandardTestDispatcher(scheduler, name = "IO dispatcher")<br>        val dispatcher2 = StandardTestDispatcher(scheduler, name = "Background dispatcher")<br>        launch(dispatcher1) {<br>            delay(1_000)<br>            println("1. $currentTime") // 1000<br>            delay(200)<br>            println("2. $currentTime") // 1200<br>            delay(2_000)<br>            println("4. $currentTime") // 3200<br>        }<br>        val deferred = async(dispatcher2) {<br>            delay(3_000)<br>            println("3. $currentTime") // 3000<br>            delay(500)<br>            println("5. $currentTime") // 3500<br>        }<br>        deferred.await()<br>    }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph"><strong>Note: if </strong><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html"><strong>Dispatchers.Main</strong></a><strong> is replaced by a </strong><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html"><strong>TestDispatcher</strong></a><strong>, </strong><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html"><strong>runTest</strong></a><strong> will automatically use its scheduler. This is done so that there is no need to go through the ceremony of passing the correct scheduler to </strong><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html"><strong>runTest</strong></a><strong>.</strong></p><h2 class=""> Accessing the test coroutine scope</h2><p class="paragraph">Structured concurrency ties coroutines to scopes in which they are launched. <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a> is a special coroutine scope designed for testing coroutines, and a new one is automatically created for <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> and used as the receiver for the test body.</p><p class="paragraph">However, it can be convenient to access a <code class="lang-kotlin">CoroutineScope</code> before the test has started, for example, to perform mocking of some parts of the system in <code class="lang-kotlin">@BeforeTest</code> via dependency injection. In these cases, it is possible to manually create <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a>, the scope for the test coroutines, in advance, before the test begins.</p><p class="paragraph"><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a> on its own does not automatically run the code launched in it. In addition, it is stateful in order to keep track of executing coroutines and uncaught exceptions. Therefore, it is important to ensure that <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">TestScope.runTest</a> is called eventually.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">val scope = TestScope()<br><br>@BeforeTest<br>fun setUp() {<br>    Dispatchers.setMain(StandardTestDispatcher(scope.testScheduler))<br>    TestSubject.setScope(scope)<br>}<br><br>@AfterTest<br>fun tearDown() {<br>    Dispatchers.resetMain()<br>    TestSubject.resetScope()<br>}<br><br>@Test<br>fun testSubject() = scope.runTest {<br>    // the receiver here is `testScope`<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Running background work</h2><p class="paragraph">Sometimes, the fact that <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> waits for all the coroutines to finish is undesired. For example, the system under test may need to receive data from coroutines that always run in the background. Emulating such coroutines by launching them from the test body is not sufficient, because <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> will wait for them to finish, which they never typically do.</p><p class="paragraph">For these cases, there is a special coroutine scope: <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/background-scope.html">TestScope.backgroundScope</a>. Coroutines launched in it will be cancelled at the end of the test.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testExampleBackgroundJob() = runTest {<br>  val channel = Channel&lt;Int&gt;()<br>  backgroundScope.launch {<br>    var i = 0<br>    while (true) {<br>      channel.send(i++)<br>    }<br>  }<br>  repeat(100) {<br>    assertEquals(it, channel.receive())<br>  }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Eagerly entering <code class="lang-kotlin">launch</code> and <code class="lang-kotlin">async</code> blocks</h2><p class="paragraph">Some tests only test functionality and don't particularly care about the precise order in which coroutines are dispatched. In these cases, it can be cumbersome to always call <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-current.html">runCurrent</a> or <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html">yield</a> to observe the effects of the coroutines after they are launched.</p><p class="paragraph">If <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> executes with an <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-unconfined-test-dispatcher.html">UnconfinedTestDispatcher</a>, the child coroutines launched at the top level are entered <i>eagerly</i>, that is, they don't go through a dispatch until the first suspension.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testEagerlyEnteringChildCoroutines() = runTest(UnconfinedTestDispatcher()) {<br>    var entered = false<br>    val deferred = CompletableDeferred&lt;Unit&gt;()<br>    var completed = false<br>    launch {<br>        entered = true<br>        deferred.await()<br>        completed = true<br>    }<br>    assertTrue(entered) // `entered = true` already executed.<br>    assertFalse(completed) // however, the child coroutine then suspended, so it is enqueued.<br>    deferred.complete(Unit) // resume the coroutine.<br>    assertTrue(completed) // now the child coroutine is immediately completed.<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">If this behavior is desirable, but some parts of the test still require accurate dispatching, for example, to ensure that the code executes on the correct thread, then simply <code class="lang-kotlin">launch</code> a new coroutine with the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-standard-test-dispatcher.html">StandardTestDispatcher</a>.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testEagerlyEnteringSomeChildCoroutines() = runTest(UnconfinedTestDispatcher()) {<br>    var entered1 = false<br>    launch {<br>        entered1 = true<br>    }<br>    assertTrue(entered1) // `entered1 = true` already executed<br><br>    var entered2 = false<br>    launch(StandardTestDispatcher(testScheduler)) {<br>        // this block and every coroutine launched inside it will explicitly go through the needed dispatches<br>        entered2 = true<br>    }<br>    assertFalse(entered2)<br>    runCurrent() // need to explicitly run the dispatched continuation<br>    assertTrue(entered2)<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class=""> Using <code class="lang-kotlin">withTimeout</code> inside <code class="lang-kotlin">runTest</code></h3><p class="paragraph">Timeouts are also susceptible to time control, so the code below will immediately finish.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFooWithTimeout() = runTest {<br>    assertFailsWith&lt;TimeoutCancellationException&gt; {<br>        withTimeout(1_000) {<br>            delay(999)<br>            delay(2)<br>            println("this won't be reached")<br>        }<br>    }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Virtual time support with other dispatchers</h2><p class="paragraph">Calls to <code class="lang-kotlin">withContext(Dispatchers.IO)</code>, <code class="lang-kotlin">withContext(Dispatchers.Default)</code> ,and <code class="lang-kotlin">withContext(Dispatchers.Main)</code> are common in coroutines-based code bases. Unfortunately, just executing code in a test will not lead to these dispatchers using the virtual time source, so delays will not be skipped in them.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">suspend fun veryExpensiveFunction() = withContext(Dispatchers.Default) {<br>    delay(1_000)<br>    1<br>}<br><br>fun testExpensiveFunction() = runTest {<br>    val result = veryExpensiveFunction() // will take a whole real-time second to execute<br>    // the virtual time at this point is still 0<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Tests should, when possible, replace these dispatchers with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a> if the <code class="lang-kotlin">withContext</code> calls <code class="lang-kotlin">delay</code> in the function under test. For example, <code class="lang-kotlin">veryExpensiveFunction</code> above should allow mocking with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a> using either dependency injection, a service locator, or a default parameter, if it is to be used with virtual time.</p><h3 class=""> Status of the API</h3><p class="paragraph">Many parts of the API is experimental, and it is may change before migrating out of experimental (while it is marked as <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-experimental-coroutines-api/index.html"><code class="lang-kotlin">@ExperimentalCoroutinesApi</code></a>). Changes during experimental may have deprecation applied when possible, but it is not advised to use the API in stable code before it leaves experimental due to possible breaking changes.</p><p class="paragraph">If you have any suggestions for improvements to this experimental API please share them on the <a href="https://github.com/Kotlin/kotlinx.coroutines/issues">issue tracker</a>.</p><!-- MODULE kotlinx-coroutines-core --><!-- INDEX kotlinx.coroutines --><!-- MODULE kotlinx-coroutines-test --><!-- INDEX kotlinx.coroutines.test --><!-- END --></div><div class="content sourceset-dependent-content" data-togglable=":kotlinx-coroutines-test:dokkaHtmlPartial/jvmMain"><p class="paragraph">Test utilities for <code class="lang-kotlin">kotlinx.coroutines</code>.</p><h2 class=""> Overview</h2><p class="paragraph">This package provides utilities for efficiently testing coroutines.</p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a></td><td>Runs the test code, automatically skipping delays and handling uncaught exceptions.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a></td><td>The shared source of virtual time, used for controlling execution order and skipping delays.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a></td><td>A <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> that integrates with <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a>, providing access to <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a></td><td>A <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">CoroutineDispatcher</a> whose delays are controlled by a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/set-main.html">Dispatchers.setMain</a></td><td>Mocks the main dispatcher using the provided one. If mocked with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a>, its <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a> is used everywhere by default.</td></tr></tbody></table><p class="paragraph">Provided <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a> implementations:</p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-standard-test-dispatcher.html">StandardTestDispatcher</a></td><td>A simple dispatcher with no special behavior other than being linked to a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-unconfined-test-dispatcher.html">UnconfinedTestDispatcher</a></td><td>A dispatcher that behaves like <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html">Dispatchers.Unconfined</a>.</td></tr></tbody></table><h2 class=""> Using in your project</h2><p class="paragraph">Add <code class="lang-kotlin">kotlinx-coroutines-test</code> to your project test dependencies:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">dependencies {<br>    testImplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.1'<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph"><strong>Do not</strong> depend on this project in your main sources, all utilities here are intended and designed to be used only from tests.</p><h2 class=""> Dispatchers.Main Delegation</h2><p class="paragraph"><code class="lang-kotlin">Dispatchers.setMain</code> will override the <code class="lang-kotlin">Main</code> dispatcher in test scenarios. This is helpful when one wants to execute a test in situations where the platform <code class="lang-kotlin">Main</code> dispatcher is not available, or to replace <code class="lang-kotlin">Dispatchers.Main</code> with a testing dispatcher.</p><p class="paragraph">On the JVM, the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html"><code class="lang-kotlin">ServiceLoader</code></a> mechanism is responsible for overwriting <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html">Dispatchers.Main</a> with a testable implementation, which by default will delegate its calls to the real <code class="lang-kotlin">Main</code> dispatcher, if any.</p><p class="paragraph">The <code class="lang-kotlin">Main</code> implementation can be overridden using <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/set-main.html">Dispatchers.setMain</a> method with any <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">CoroutineDispatcher</a> implementation, e.g.:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">class SomeTest {<br><br>    private val mainThreadSurrogate = newSingleThreadContext("UI thread")<br><br>    @Before<br>    fun setUp() {<br>        Dispatchers.setMain(mainThreadSurrogate)<br>    }<br><br>    @After<br>    fun tearDown() {<br>        Dispatchers.resetMain() // reset the main dispatcher to the original Main dispatcher<br>        mainThreadSurrogate.close()<br>    }<br><br>    @Test<br>    fun testSomeUI() = runBlocking {<br>        launch(Dispatchers.Main) {  // Will be launched in the mainThreadSurrogate dispatcher<br>            // ...<br>        }<br>    }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Calling <code class="lang-kotlin">setMain</code> or <code class="lang-kotlin">resetMain</code> immediately changes the <code class="lang-kotlin">Main</code> dispatcher globally.</p><p class="paragraph">If <code class="lang-kotlin">Main</code> is overridden with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a>, then its <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a> is used when new <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a> or <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a> instances are created without <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a> being passed as an argument.</p><h2 class=""> runTest</h2><p class="paragraph"><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> is the way to test code that involves coroutines. <code class="lang-kotlin">suspend</code> functions can be called inside it.</p><p class="paragraph"><strong>IMPORTANT: in order to work with on Kotlin/JS, the result of </strong><code class="strong lang-kotlin"><strong>runTest</strong></code><strong> must be immediately </strong><code class="strong lang-kotlin"><strong>return</strong></code><strong>-ed from each test.</strong> The typical invocation of <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> thus looks like this:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFoo() = runTest {<br>    // code under test<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">In more advanced scenarios, it's possible instead to use the following form:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFoo(): TestResult {<br>    // initialize some test state<br>    return runTest {<br>        // code under test<br>    }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph"><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> is similar to running the code with <code class="lang-kotlin">runBlocking</code> on Kotlin/JVM and Kotlin/Native, or launching a new promise on Kotlin/JS. The main differences are the following:</p><ul><li><p class="paragraph"><strong>The calls to </strong><code class="strong lang-kotlin"><strong>delay</strong></code><strong> are automatically skipped</strong>, preserving the relative execution order of the tasks. This way,   it's possible to make tests finish more-or-less immediately.</p></li><li><p class="paragraph"><strong>The execution times out after 10 seconds</strong>, cancelling the test coroutine to prevent tests from hanging forever    and eating up the CI resources.</p></li><li><p class="paragraph"><strong>Controlling the virtual time</strong>: in case just skipping delays is not sufficient, it's possible to more carefully   guide the execution, advancing the virtual time by a duration, draining the queue of the awaiting tasks, or running   the tasks scheduled at the present moment.</p></li><li><p class="paragraph"><strong>Handling uncaught exceptions</strong> spawned in the child coroutines by throwing them at the end of the test.</p></li><li><p class="paragraph"><strong>Waiting for asynchronous callbacks</strong>.   Sometimes, especially when working with third-party code, it's impossible to mock all the dispatchers in use.   <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> will handle the situations where some code runs in dispatchers not integrated with the test module.</p></li></ul><h2 class=""> Timeout</h2><p class="paragraph">Test automatically time out after 10 seconds. For example, this test will fail with a timeout exception:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testHanging() = runTest {<br>    CompletableDeferred&lt;Unit&gt;().await() // will hang forever<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">In case the test is expected to take longer than 10 seconds, the timeout can be increased by passing the <code class="lang-kotlin">timeout</code> parameter:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testTakingALongTime() = runTest(timeout = 30.seconds) {<br>    val result = withContext(Dispatchers.Default) {<br>        delay(20.seconds) // this delay is not in the test dispatcher and will not be skipped<br>        3<br>    }<br>    assertEquals(3, result)<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Delay-skipping</h2><p class="paragraph">To test regular suspend functions, which may have a delay, just run them inside the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> block.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFoo() = runTest { // a coroutine with an extra test control<br>    val actual = foo()<br>    // ...<br>}<br><br>suspend fun foo() {<br>    delay(1_000) // when run in `runTest`, will finish immediately instead of delaying<br>    // ...<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> <code class="lang-kotlin">launch</code> and <code class="lang-kotlin">async</code></h2><p class="paragraph">The coroutine dispatcher used for tests is single-threaded, meaning that the child coroutines of the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> block will run on the thread that started the test, and will never run in parallel.</p><p class="paragraph">If several coroutines are waiting to be executed next, the one scheduled after the smallest delay will be chosen. The virtual time will automatically advance to the point of its resumption.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testWithMultipleDelays() = runTest {<br>    launch {<br>        delay(1_000)<br>        println("1. $currentTime") // 1000<br>        delay(200)<br>        println("2. $currentTime") // 1200<br>        delay(2_000)<br>        println("4. $currentTime") // 3200<br>    }<br>    val deferred = async {<br>        delay(3_000)<br>        println("3. $currentTime") // 3000<br>        delay(500)<br>        println("5. $currentTime") // 3500<br>    }<br>    deferred.await()<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Controlling the virtual time</h2><p class="paragraph">Inside <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a>, the execution is scheduled by <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>, which is a virtual time scheduler. The scheduler has several special methods that allow controlling the virtual time:</p><ul><li><p class="paragraph"><code class="lang-kotlin">currentTime</code> gets the current virtual time.</p></li><li><p class="paragraph"><code class="lang-kotlin">runCurrent()</code> runs the tasks that are scheduled at this point of virtual time.</p></li><li><p class="paragraph"><code class="lang-kotlin">advanceUntilIdle()</code> runs all enqueued tasks until there are no more.</p></li><li><p class="paragraph"><code class="lang-kotlin">advanceTimeBy(timeDelta)</code> runs the enqueued tasks until the current virtual time advances by <code class="lang-kotlin">timeDelta</code>.</p></li><li><p class="paragraph"><code class="lang-kotlin">timeSource</code> returns a <code class="lang-kotlin">TimeSource</code> that uses the virtual time.</p></li></ul><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFoo() = runTest {<br>    launch {<br>        val workDuration = testScheduler.timeSource.measureTime {<br>            println(1)   // executes during runCurrent()<br>            delay(1_000) // suspends until time is advanced by at least 1_000<br>            println(2)   // executes during advanceTimeBy(2_000)<br>            delay(500)   // suspends until the time is advanced by another 500 ms<br>            println(3)   // also executes during advanceTimeBy(2_000)<br>            delay(5_000) // will suspend by another 4_500 ms<br>            println(4)   // executes during advanceUntilIdle()<br>        }<br>        assertEquals(6500.milliseconds, workDuration) // the work took 6_500 ms of virtual time<br>    }<br>    // the child coroutine has not run yet<br>    testScheduler.runCurrent()<br>    // the child coroutine has called println(1), and is suspended on delay(1_000)<br>    testScheduler.advanceTimeBy(2.seconds) // progress time, this will cause two calls to `delay` to resume<br>    // the child coroutine has called println(2) and println(3) and suspends for another 4_500 virtual milliseconds<br>    testScheduler.advanceUntilIdle() // will run the child coroutine to completion<br>    assertEquals(6500, currentTime) // the child coroutine finished at virtual time of 6_500 milliseconds<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Using multiple test dispatchers</h2><p class="paragraph">The virtual time is controlled by an entity called the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>, which behaves as the shared source of virtual time.</p><p class="paragraph">Several dispatchers can be created that use the same <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>, in which case they will share their knowledge of the virtual time.</p><p class="paragraph">To access the scheduler used for this test, use the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/test-scheduler.html">TestScope.testScheduler</a> property.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testWithMultipleDispatchers() = runTest {<br>        val scheduler = testScheduler // the scheduler used for this test<br>        val dispatcher1 = StandardTestDispatcher(scheduler, name = "IO dispatcher")<br>        val dispatcher2 = StandardTestDispatcher(scheduler, name = "Background dispatcher")<br>        launch(dispatcher1) {<br>            delay(1_000)<br>            println("1. $currentTime") // 1000<br>            delay(200)<br>            println("2. $currentTime") // 1200<br>            delay(2_000)<br>            println("4. $currentTime") // 3200<br>        }<br>        val deferred = async(dispatcher2) {<br>            delay(3_000)<br>            println("3. $currentTime") // 3000<br>            delay(500)<br>            println("5. $currentTime") // 3500<br>        }<br>        deferred.await()<br>    }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph"><strong>Note: if </strong><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html"><strong>Dispatchers.Main</strong></a><strong> is replaced by a </strong><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html"><strong>TestDispatcher</strong></a><strong>, </strong><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html"><strong>runTest</strong></a><strong> will automatically use its scheduler. This is done so that there is no need to go through the ceremony of passing the correct scheduler to </strong><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html"><strong>runTest</strong></a><strong>.</strong></p><h2 class=""> Accessing the test coroutine scope</h2><p class="paragraph">Structured concurrency ties coroutines to scopes in which they are launched. <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a> is a special coroutine scope designed for testing coroutines, and a new one is automatically created for <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> and used as the receiver for the test body.</p><p class="paragraph">However, it can be convenient to access a <code class="lang-kotlin">CoroutineScope</code> before the test has started, for example, to perform mocking of some parts of the system in <code class="lang-kotlin">@BeforeTest</code> via dependency injection. In these cases, it is possible to manually create <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a>, the scope for the test coroutines, in advance, before the test begins.</p><p class="paragraph"><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a> on its own does not automatically run the code launched in it. In addition, it is stateful in order to keep track of executing coroutines and uncaught exceptions. Therefore, it is important to ensure that <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">TestScope.runTest</a> is called eventually.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">val scope = TestScope()<br><br>@BeforeTest<br>fun setUp() {<br>    Dispatchers.setMain(StandardTestDispatcher(scope.testScheduler))<br>    TestSubject.setScope(scope)<br>}<br><br>@AfterTest<br>fun tearDown() {<br>    Dispatchers.resetMain()<br>    TestSubject.resetScope()<br>}<br><br>@Test<br>fun testSubject() = scope.runTest {<br>    // the receiver here is `testScope`<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Running background work</h2><p class="paragraph">Sometimes, the fact that <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> waits for all the coroutines to finish is undesired. For example, the system under test may need to receive data from coroutines that always run in the background. Emulating such coroutines by launching them from the test body is not sufficient, because <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> will wait for them to finish, which they never typically do.</p><p class="paragraph">For these cases, there is a special coroutine scope: <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/background-scope.html">TestScope.backgroundScope</a>. Coroutines launched in it will be cancelled at the end of the test.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testExampleBackgroundJob() = runTest {<br>  val channel = Channel&lt;Int&gt;()<br>  backgroundScope.launch {<br>    var i = 0<br>    while (true) {<br>      channel.send(i++)<br>    }<br>  }<br>  repeat(100) {<br>    assertEquals(it, channel.receive())<br>  }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Eagerly entering <code class="lang-kotlin">launch</code> and <code class="lang-kotlin">async</code> blocks</h2><p class="paragraph">Some tests only test functionality and don't particularly care about the precise order in which coroutines are dispatched. In these cases, it can be cumbersome to always call <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-current.html">runCurrent</a> or <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html">yield</a> to observe the effects of the coroutines after they are launched.</p><p class="paragraph">If <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> executes with an <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-unconfined-test-dispatcher.html">UnconfinedTestDispatcher</a>, the child coroutines launched at the top level are entered <i>eagerly</i>, that is, they don't go through a dispatch until the first suspension.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testEagerlyEnteringChildCoroutines() = runTest(UnconfinedTestDispatcher()) {<br>    var entered = false<br>    val deferred = CompletableDeferred&lt;Unit&gt;()<br>    var completed = false<br>    launch {<br>        entered = true<br>        deferred.await()<br>        completed = true<br>    }<br>    assertTrue(entered) // `entered = true` already executed.<br>    assertFalse(completed) // however, the child coroutine then suspended, so it is enqueued.<br>    deferred.complete(Unit) // resume the coroutine.<br>    assertTrue(completed) // now the child coroutine is immediately completed.<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">If this behavior is desirable, but some parts of the test still require accurate dispatching, for example, to ensure that the code executes on the correct thread, then simply <code class="lang-kotlin">launch</code> a new coroutine with the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-standard-test-dispatcher.html">StandardTestDispatcher</a>.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testEagerlyEnteringSomeChildCoroutines() = runTest(UnconfinedTestDispatcher()) {<br>    var entered1 = false<br>    launch {<br>        entered1 = true<br>    }<br>    assertTrue(entered1) // `entered1 = true` already executed<br><br>    var entered2 = false<br>    launch(StandardTestDispatcher(testScheduler)) {<br>        // this block and every coroutine launched inside it will explicitly go through the needed dispatches<br>        entered2 = true<br>    }<br>    assertFalse(entered2)<br>    runCurrent() // need to explicitly run the dispatched continuation<br>    assertTrue(entered2)<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class=""> Using <code class="lang-kotlin">withTimeout</code> inside <code class="lang-kotlin">runTest</code></h3><p class="paragraph">Timeouts are also susceptible to time control, so the code below will immediately finish.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFooWithTimeout() = runTest {<br>    assertFailsWith&lt;TimeoutCancellationException&gt; {<br>        withTimeout(1_000) {<br>            delay(999)<br>            delay(2)<br>            println("this won't be reached")<br>        }<br>    }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Virtual time support with other dispatchers</h2><p class="paragraph">Calls to <code class="lang-kotlin">withContext(Dispatchers.IO)</code>, <code class="lang-kotlin">withContext(Dispatchers.Default)</code> ,and <code class="lang-kotlin">withContext(Dispatchers.Main)</code> are common in coroutines-based code bases. Unfortunately, just executing code in a test will not lead to these dispatchers using the virtual time source, so delays will not be skipped in them.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">suspend fun veryExpensiveFunction() = withContext(Dispatchers.Default) {<br>    delay(1_000)<br>    1<br>}<br><br>fun testExpensiveFunction() = runTest {<br>    val result = veryExpensiveFunction() // will take a whole real-time second to execute<br>    // the virtual time at this point is still 0<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Tests should, when possible, replace these dispatchers with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a> if the <code class="lang-kotlin">withContext</code> calls <code class="lang-kotlin">delay</code> in the function under test. For example, <code class="lang-kotlin">veryExpensiveFunction</code> above should allow mocking with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a> using either dependency injection, a service locator, or a default parameter, if it is to be used with virtual time.</p><h3 class=""> Status of the API</h3><p class="paragraph">Many parts of the API is experimental, and it is may change before migrating out of experimental (while it is marked as <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-experimental-coroutines-api/index.html"><code class="lang-kotlin">@ExperimentalCoroutinesApi</code></a>). Changes during experimental may have deprecation applied when possible, but it is not advised to use the API in stable code before it leaves experimental due to possible breaking changes.</p><p class="paragraph">If you have any suggestions for improvements to this experimental API please share them on the <a href="https://github.com/Kotlin/kotlinx.coroutines/issues">issue tracker</a>.</p><!-- MODULE kotlinx-coroutines-core --><!-- INDEX kotlinx.coroutines --><!-- MODULE kotlinx-coroutines-test --><!-- INDEX kotlinx.coroutines.test --><!-- END --></div><div class="content sourceset-dependent-content" data-togglable=":kotlinx-coroutines-test:dokkaHtmlPartial/nativeMain"><p class="paragraph">Test utilities for <code class="lang-kotlin">kotlinx.coroutines</code>.</p><h2 class=""> Overview</h2><p class="paragraph">This package provides utilities for efficiently testing coroutines.</p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a></td><td>Runs the test code, automatically skipping delays and handling uncaught exceptions.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a></td><td>The shared source of virtual time, used for controlling execution order and skipping delays.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a></td><td>A <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> that integrates with <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a>, providing access to <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a></td><td>A <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">CoroutineDispatcher</a> whose delays are controlled by a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/set-main.html">Dispatchers.setMain</a></td><td>Mocks the main dispatcher using the provided one. If mocked with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a>, its <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a> is used everywhere by default.</td></tr></tbody></table><p class="paragraph">Provided <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a> implementations:</p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-standard-test-dispatcher.html">StandardTestDispatcher</a></td><td>A simple dispatcher with no special behavior other than being linked to a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>.</td></tr><tr><td><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-unconfined-test-dispatcher.html">UnconfinedTestDispatcher</a></td><td>A dispatcher that behaves like <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html">Dispatchers.Unconfined</a>.</td></tr></tbody></table><h2 class=""> Using in your project</h2><p class="paragraph">Add <code class="lang-kotlin">kotlinx-coroutines-test</code> to your project test dependencies:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">dependencies {<br>    testImplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.1'<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph"><strong>Do not</strong> depend on this project in your main sources, all utilities here are intended and designed to be used only from tests.</p><h2 class=""> Dispatchers.Main Delegation</h2><p class="paragraph"><code class="lang-kotlin">Dispatchers.setMain</code> will override the <code class="lang-kotlin">Main</code> dispatcher in test scenarios. This is helpful when one wants to execute a test in situations where the platform <code class="lang-kotlin">Main</code> dispatcher is not available, or to replace <code class="lang-kotlin">Dispatchers.Main</code> with a testing dispatcher.</p><p class="paragraph">On the JVM, the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html"><code class="lang-kotlin">ServiceLoader</code></a> mechanism is responsible for overwriting <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html">Dispatchers.Main</a> with a testable implementation, which by default will delegate its calls to the real <code class="lang-kotlin">Main</code> dispatcher, if any.</p><p class="paragraph">The <code class="lang-kotlin">Main</code> implementation can be overridden using <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/set-main.html">Dispatchers.setMain</a> method with any <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">CoroutineDispatcher</a> implementation, e.g.:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">class SomeTest {<br><br>    private val mainThreadSurrogate = newSingleThreadContext("UI thread")<br><br>    @Before<br>    fun setUp() {<br>        Dispatchers.setMain(mainThreadSurrogate)<br>    }<br><br>    @After<br>    fun tearDown() {<br>        Dispatchers.resetMain() // reset the main dispatcher to the original Main dispatcher<br>        mainThreadSurrogate.close()<br>    }<br><br>    @Test<br>    fun testSomeUI() = runBlocking {<br>        launch(Dispatchers.Main) {  // Will be launched in the mainThreadSurrogate dispatcher<br>            // ...<br>        }<br>    }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Calling <code class="lang-kotlin">setMain</code> or <code class="lang-kotlin">resetMain</code> immediately changes the <code class="lang-kotlin">Main</code> dispatcher globally.</p><p class="paragraph">If <code class="lang-kotlin">Main</code> is overridden with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a>, then its <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a> is used when new <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a> or <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a> instances are created without <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a> being passed as an argument.</p><h2 class=""> runTest</h2><p class="paragraph"><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> is the way to test code that involves coroutines. <code class="lang-kotlin">suspend</code> functions can be called inside it.</p><p class="paragraph"><strong>IMPORTANT: in order to work with on Kotlin/JS, the result of </strong><code class="strong lang-kotlin"><strong>runTest</strong></code><strong> must be immediately </strong><code class="strong lang-kotlin"><strong>return</strong></code><strong>-ed from each test.</strong> The typical invocation of <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> thus looks like this:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFoo() = runTest {<br>    // code under test<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">In more advanced scenarios, it's possible instead to use the following form:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFoo(): TestResult {<br>    // initialize some test state<br>    return runTest {<br>        // code under test<br>    }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph"><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> is similar to running the code with <code class="lang-kotlin">runBlocking</code> on Kotlin/JVM and Kotlin/Native, or launching a new promise on Kotlin/JS. The main differences are the following:</p><ul><li><p class="paragraph"><strong>The calls to </strong><code class="strong lang-kotlin"><strong>delay</strong></code><strong> are automatically skipped</strong>, preserving the relative execution order of the tasks. This way,   it's possible to make tests finish more-or-less immediately.</p></li><li><p class="paragraph"><strong>The execution times out after 10 seconds</strong>, cancelling the test coroutine to prevent tests from hanging forever    and eating up the CI resources.</p></li><li><p class="paragraph"><strong>Controlling the virtual time</strong>: in case just skipping delays is not sufficient, it's possible to more carefully   guide the execution, advancing the virtual time by a duration, draining the queue of the awaiting tasks, or running   the tasks scheduled at the present moment.</p></li><li><p class="paragraph"><strong>Handling uncaught exceptions</strong> spawned in the child coroutines by throwing them at the end of the test.</p></li><li><p class="paragraph"><strong>Waiting for asynchronous callbacks</strong>.   Sometimes, especially when working with third-party code, it's impossible to mock all the dispatchers in use.   <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> will handle the situations where some code runs in dispatchers not integrated with the test module.</p></li></ul><h2 class=""> Timeout</h2><p class="paragraph">Test automatically time out after 10 seconds. For example, this test will fail with a timeout exception:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testHanging() = runTest {<br>    CompletableDeferred&lt;Unit&gt;().await() // will hang forever<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">In case the test is expected to take longer than 10 seconds, the timeout can be increased by passing the <code class="lang-kotlin">timeout</code> parameter:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testTakingALongTime() = runTest(timeout = 30.seconds) {<br>    val result = withContext(Dispatchers.Default) {<br>        delay(20.seconds) // this delay is not in the test dispatcher and will not be skipped<br>        3<br>    }<br>    assertEquals(3, result)<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Delay-skipping</h2><p class="paragraph">To test regular suspend functions, which may have a delay, just run them inside the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> block.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFoo() = runTest { // a coroutine with an extra test control<br>    val actual = foo()<br>    // ...<br>}<br><br>suspend fun foo() {<br>    delay(1_000) // when run in `runTest`, will finish immediately instead of delaying<br>    // ...<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> <code class="lang-kotlin">launch</code> and <code class="lang-kotlin">async</code></h2><p class="paragraph">The coroutine dispatcher used for tests is single-threaded, meaning that the child coroutines of the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> block will run on the thread that started the test, and will never run in parallel.</p><p class="paragraph">If several coroutines are waiting to be executed next, the one scheduled after the smallest delay will be chosen. The virtual time will automatically advance to the point of its resumption.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testWithMultipleDelays() = runTest {<br>    launch {<br>        delay(1_000)<br>        println("1. $currentTime") // 1000<br>        delay(200)<br>        println("2. $currentTime") // 1200<br>        delay(2_000)<br>        println("4. $currentTime") // 3200<br>    }<br>    val deferred = async {<br>        delay(3_000)<br>        println("3. $currentTime") // 3000<br>        delay(500)<br>        println("5. $currentTime") // 3500<br>    }<br>    deferred.await()<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Controlling the virtual time</h2><p class="paragraph">Inside <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a>, the execution is scheduled by <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>, which is a virtual time scheduler. The scheduler has several special methods that allow controlling the virtual time:</p><ul><li><p class="paragraph"><code class="lang-kotlin">currentTime</code> gets the current virtual time.</p></li><li><p class="paragraph"><code class="lang-kotlin">runCurrent()</code> runs the tasks that are scheduled at this point of virtual time.</p></li><li><p class="paragraph"><code class="lang-kotlin">advanceUntilIdle()</code> runs all enqueued tasks until there are no more.</p></li><li><p class="paragraph"><code class="lang-kotlin">advanceTimeBy(timeDelta)</code> runs the enqueued tasks until the current virtual time advances by <code class="lang-kotlin">timeDelta</code>.</p></li><li><p class="paragraph"><code class="lang-kotlin">timeSource</code> returns a <code class="lang-kotlin">TimeSource</code> that uses the virtual time.</p></li></ul><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFoo() = runTest {<br>    launch {<br>        val workDuration = testScheduler.timeSource.measureTime {<br>            println(1)   // executes during runCurrent()<br>            delay(1_000) // suspends until time is advanced by at least 1_000<br>            println(2)   // executes during advanceTimeBy(2_000)<br>            delay(500)   // suspends until the time is advanced by another 500 ms<br>            println(3)   // also executes during advanceTimeBy(2_000)<br>            delay(5_000) // will suspend by another 4_500 ms<br>            println(4)   // executes during advanceUntilIdle()<br>        }<br>        assertEquals(6500.milliseconds, workDuration) // the work took 6_500 ms of virtual time<br>    }<br>    // the child coroutine has not run yet<br>    testScheduler.runCurrent()<br>    // the child coroutine has called println(1), and is suspended on delay(1_000)<br>    testScheduler.advanceTimeBy(2.seconds) // progress time, this will cause two calls to `delay` to resume<br>    // the child coroutine has called println(2) and println(3) and suspends for another 4_500 virtual milliseconds<br>    testScheduler.advanceUntilIdle() // will run the child coroutine to completion<br>    assertEquals(6500, currentTime) // the child coroutine finished at virtual time of 6_500 milliseconds<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Using multiple test dispatchers</h2><p class="paragraph">The virtual time is controlled by an entity called the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>, which behaves as the shared source of virtual time.</p><p class="paragraph">Several dispatchers can be created that use the same <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scheduler/index.html">TestCoroutineScheduler</a>, in which case they will share their knowledge of the virtual time.</p><p class="paragraph">To access the scheduler used for this test, use the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/test-scheduler.html">TestScope.testScheduler</a> property.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testWithMultipleDispatchers() = runTest {<br>        val scheduler = testScheduler // the scheduler used for this test<br>        val dispatcher1 = StandardTestDispatcher(scheduler, name = "IO dispatcher")<br>        val dispatcher2 = StandardTestDispatcher(scheduler, name = "Background dispatcher")<br>        launch(dispatcher1) {<br>            delay(1_000)<br>            println("1. $currentTime") // 1000<br>            delay(200)<br>            println("2. $currentTime") // 1200<br>            delay(2_000)<br>            println("4. $currentTime") // 3200<br>        }<br>        val deferred = async(dispatcher2) {<br>            delay(3_000)<br>            println("3. $currentTime") // 3000<br>            delay(500)<br>            println("5. $currentTime") // 3500<br>        }<br>        deferred.await()<br>    }</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph"><strong>Note: if </strong><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html"><strong>Dispatchers.Main</strong></a><strong> is replaced by a </strong><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html"><strong>TestDispatcher</strong></a><strong>, </strong><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html"><strong>runTest</strong></a><strong> will automatically use its scheduler. This is done so that there is no need to go through the ceremony of passing the correct scheduler to </strong><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html"><strong>runTest</strong></a><strong>.</strong></p><h2 class=""> Accessing the test coroutine scope</h2><p class="paragraph">Structured concurrency ties coroutines to scopes in which they are launched. <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a> is a special coroutine scope designed for testing coroutines, and a new one is automatically created for <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> and used as the receiver for the test body.</p><p class="paragraph">However, it can be convenient to access a <code class="lang-kotlin">CoroutineScope</code> before the test has started, for example, to perform mocking of some parts of the system in <code class="lang-kotlin">@BeforeTest</code> via dependency injection. In these cases, it is possible to manually create <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a>, the scope for the test coroutines, in advance, before the test begins.</p><p class="paragraph"><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/index.html">TestScope</a> on its own does not automatically run the code launched in it. In addition, it is stateful in order to keep track of executing coroutines and uncaught exceptions. Therefore, it is important to ensure that <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">TestScope.runTest</a> is called eventually.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">val scope = TestScope()<br><br>@BeforeTest<br>fun setUp() {<br>    Dispatchers.setMain(StandardTestDispatcher(scope.testScheduler))<br>    TestSubject.setScope(scope)<br>}<br><br>@AfterTest<br>fun tearDown() {<br>    Dispatchers.resetMain()<br>    TestSubject.resetScope()<br>}<br><br>@Test<br>fun testSubject() = scope.runTest {<br>    // the receiver here is `testScope`<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Running background work</h2><p class="paragraph">Sometimes, the fact that <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> waits for all the coroutines to finish is undesired. For example, the system under test may need to receive data from coroutines that always run in the background. Emulating such coroutines by launching them from the test body is not sufficient, because <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> will wait for them to finish, which they never typically do.</p><p class="paragraph">For these cases, there is a special coroutine scope: <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-scope/background-scope.html">TestScope.backgroundScope</a>. Coroutines launched in it will be cancelled at the end of the test.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testExampleBackgroundJob() = runTest {<br>  val channel = Channel&lt;Int&gt;()<br>  backgroundScope.launch {<br>    var i = 0<br>    while (true) {<br>      channel.send(i++)<br>    }<br>  }<br>  repeat(100) {<br>    assertEquals(it, channel.receive())<br>  }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Eagerly entering <code class="lang-kotlin">launch</code> and <code class="lang-kotlin">async</code> blocks</h2><p class="paragraph">Some tests only test functionality and don't particularly care about the precise order in which coroutines are dispatched. In these cases, it can be cumbersome to always call <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-current.html">runCurrent</a> or <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html">yield</a> to observe the effects of the coroutines after they are launched.</p><p class="paragraph">If <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html">runTest</a> executes with an <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-unconfined-test-dispatcher.html">UnconfinedTestDispatcher</a>, the child coroutines launched at the top level are entered <i>eagerly</i>, that is, they don't go through a dispatch until the first suspension.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testEagerlyEnteringChildCoroutines() = runTest(UnconfinedTestDispatcher()) {<br>    var entered = false<br>    val deferred = CompletableDeferred&lt;Unit&gt;()<br>    var completed = false<br>    launch {<br>        entered = true<br>        deferred.await()<br>        completed = true<br>    }<br>    assertTrue(entered) // `entered = true` already executed.<br>    assertFalse(completed) // however, the child coroutine then suspended, so it is enqueued.<br>    deferred.complete(Unit) // resume the coroutine.<br>    assertTrue(completed) // now the child coroutine is immediately completed.<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">If this behavior is desirable, but some parts of the test still require accurate dispatching, for example, to ensure that the code executes on the correct thread, then simply <code class="lang-kotlin">launch</code> a new coroutine with the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-standard-test-dispatcher.html">StandardTestDispatcher</a>.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testEagerlyEnteringSomeChildCoroutines() = runTest(UnconfinedTestDispatcher()) {<br>    var entered1 = false<br>    launch {<br>        entered1 = true<br>    }<br>    assertTrue(entered1) // `entered1 = true` already executed<br><br>    var entered2 = false<br>    launch(StandardTestDispatcher(testScheduler)) {<br>        // this block and every coroutine launched inside it will explicitly go through the needed dispatches<br>        entered2 = true<br>    }<br>    assertFalse(entered2)<br>    runCurrent() // need to explicitly run the dispatched continuation<br>    assertTrue(entered2)<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h3 class=""> Using <code class="lang-kotlin">withTimeout</code> inside <code class="lang-kotlin">runTest</code></h3><p class="paragraph">Timeouts are also susceptible to time control, so the code below will immediately finish.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">@Test<br>fun testFooWithTimeout() = runTest {<br>    assertFailsWith&lt;TimeoutCancellationException&gt; {<br>        withTimeout(1_000) {<br>            delay(999)<br>            delay(2)<br>            println("this won't be reached")<br>        }<br>    }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Virtual time support with other dispatchers</h2><p class="paragraph">Calls to <code class="lang-kotlin">withContext(Dispatchers.IO)</code>, <code class="lang-kotlin">withContext(Dispatchers.Default)</code> ,and <code class="lang-kotlin">withContext(Dispatchers.Main)</code> are common in coroutines-based code bases. Unfortunately, just executing code in a test will not lead to these dispatchers using the virtual time source, so delays will not be skipped in them.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">suspend fun veryExpensiveFunction() = withContext(Dispatchers.Default) {<br>    delay(1_000)<br>    1<br>}<br><br>fun testExpensiveFunction() = runTest {<br>    val result = veryExpensiveFunction() // will take a whole real-time second to execute<br>    // the virtual time at this point is still 0<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">Tests should, when possible, replace these dispatchers with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a> if the <code class="lang-kotlin">withContext</code> calls <code class="lang-kotlin">delay</code> in the function under test. For example, <code class="lang-kotlin">veryExpensiveFunction</code> above should allow mocking with a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-dispatcher/index.html">TestDispatcher</a> using either dependency injection, a service locator, or a default parameter, if it is to be used with virtual time.</p><h3 class=""> Status of the API</h3><p class="paragraph">Many parts of the API is experimental, and it is may change before migrating out of experimental (while it is marked as <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-experimental-coroutines-api/index.html"><code class="lang-kotlin">@ExperimentalCoroutinesApi</code></a>). Changes during experimental may have deprecation applied when possible, but it is not advised to use the API in stable code before it leaves experimental due to possible breaking changes.</p><p class="paragraph">If you have any suggestions for improvements to this experimental API please share them on the <a href="https://github.com/Kotlin/kotlinx.coroutines/issues">issue tracker</a>.</p><!-- MODULE kotlinx-coroutines-core --><!-- INDEX kotlinx.coroutines --><!-- MODULE kotlinx-coroutines-test --><!-- INDEX kotlinx.coroutines.test --><!-- END --></div>    </div>
  </div>
  <h2 class="">Packages</h2>
  <div class="table"><a data-name="661561616%2FPackages%2F2093488082" anchor-label="kotlinx.coroutines.test" id="661561616%2FPackages%2F2093488082" data-filterable-set=":kotlinx-coroutines-test:dokkaHtmlPartial/commonMain :kotlinx-coroutines-test:dokkaHtmlPartial/jsMain :kotlinx-coroutines-test:dokkaHtmlPartial/jvmMain :kotlinx-coroutines-test:dokkaHtmlPartial/nativeMain"></a>
    <div class="table-row" data-filterable-current=":kotlinx-coroutines-test:dokkaHtmlPartial/commonMain :kotlinx-coroutines-test:dokkaHtmlPartial/jsMain :kotlinx-coroutines-test:dokkaHtmlPartial/jvmMain :kotlinx-coroutines-test:dokkaHtmlPartial/nativeMain" data-filterable-set=":kotlinx-coroutines-test:dokkaHtmlPartial/commonMain :kotlinx-coroutines-test:dokkaHtmlPartial/jsMain :kotlinx-coroutines-test:dokkaHtmlPartial/jvmMain :kotlinx-coroutines-test:dokkaHtmlPartial/nativeMain">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="kotlinx.coroutines.test/index.html">kotlinx.coroutines.test</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="661561616%2FPackages%2F2093488082"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag common-like">common</div>
              <div class="platform-tag js-like">js</div>
              <div class="platform-tag jvm-like">jvm</div>
              <div class="platform-tag common-like">native</div>
            </div>
          </div>
        </div>
        <div></div>
      </div>
    </div>
  </div>
</div>
      <div class="footer">
        <span class="go-to-top-icon"><a href="#content" id="go-to-top-link"></a></span><span>© 2023 Copyright</span><span class="pull-right"><span>Generated by </span><a href="https://github.com/Kotlin/dokka"><span>dokka</span><span class="padded-icon"></span></a></span>
      </div>
            </div>
        </div>
    </div>
</body>
</html>

